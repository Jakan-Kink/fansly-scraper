"""FactoryBoy factories for stash-graphql-client Pydantic types (v0.10.4+).

This module provides factories for creating test instances of Stash entity types
(Performer, Studio, Scene, etc.) that are returned by stash-graphql-client v0.10.4+.

IMPORTANT: These are fully typed Pydantic models from the library, NOT Strawberry types.
Strawberry was used in the old local implementation and has been removed.

Key Patterns in v0.10.4+
========================

1. UUID Auto-Generation
-----------------------
Pydantic models automatically generate temporary UUIDs on creation. DO NOT manually
assign IDs in factories - let Pydantic handle it.

    # Factory creates object with temp UUID
    performer = PerformerFactory(name="Jane Doe")
    print(performer.id)  # e.g., "f47ac10b-58cc-4372-a567-0e02b2c3d479" (temp UUID)

    # Save to server, get real ID back
    saved = await performer.save(client)
    print(saved.id)  # e.g., "123" (real ID from Stash server)

    # Simulate server-returned object (override temp UUID)
    existing = PerformerFactory(id="123", name="Jane Doe")

2. UNSET Pattern (Three-State Fields)
--------------------------------------
Fields have three possible states in v0.10.4:
    - Set to value:  field = "value"
    - Set to null:   field = None
    - Not touched:   field not assigned = UNSET (automatic)

DO NOT explicitly set `field = UNSET`. Just omit the field from factory definition,
and Pydantic will automatically treat it as UNSET.

    # Factory omits optional fields (automatic UNSET)
    scene = SceneFactory(title="Test")  # Only title set
    # scene.details is UNSET (not included in mutation)
    # scene.rating100 is UNSET (not included in mutation)

    # To explicitly set null (different from UNSET):
    scene = SceneFactory(title="Test", details=None)  # details=null in mutation

3. Relationship Helpers (ActiveRecord-style)
--------------------------------------------
Use helper methods for many-to-many relationships with bidirectional sync:

    scene = SceneFactory()
    await scene.add_performer(performer)  # Auto-syncs performer.scenes
    await scene.add_tag(tag)  # Auto-syncs tag.scenes
    scene.studio = studio  # Direct assignment for one-to-one

4. StashEntityStore (Identity Map + Repository)
-----------------------------------------------
The store ensures same ID = same object instance (identity map):

    p1 = await store.get(Performer, "123")
    p2 = await store.get(Performer, "123")
    assert p1 is p2  # Same object instance!

    p1.name = "Updated"
    print(p2.name)  # "Updated" (same object)

Usage Examples
==============

    from tests.fixtures import PerformerFactory, SceneFactory, StudioFactory

    # Create new object (temp UUID, for testing creation)
    new_performer = PerformerFactory(name="Jane Doe")
    saved = await new_performer.save(client)  # Gets real ID from server

    # Simulate existing object (override temp UUID)
    existing_studio = StudioFactory(id="123", name="Test Studio")

    # Test relationships
    scene = SceneFactory(title="Test Scene")
    await scene.add_performer(existing_studio)

    # Test partial updates (omitted fields are UNSET)
    update_scene = SceneFactory(title="New Title")  # Only title sent in mutation
"""

from datetime import UTC, datetime

import pytest
from factory.base import Factory
from factory.declarations import LazyAttribute, LazyFunction, Sequence
from stash_graphql_client.types import (
    Gallery,
    Group,
    Image,
    Performer,
    Scene,
    Studio,
    Tag,
)
from stash_graphql_client.types.files import Fingerprint, ImageFile, VideoFile
from stash_graphql_client.types.job import Job, JobStatus


class PerformerFactory(Factory):
    """Factory for Performer Pydantic type from stash-graphql-client.

    Creates Performer instances for testing. Pydantic automatically generates a
    temporary UUID on creation. Override with id="123" to simulate server-returned objects.

    Examples:
        # New performer (temp UUID auto-generated)
        performer = PerformerFactory(name="Jane Doe")
        print(performer.id)  # Temp UUID like "f47ac10b-..."

        # Simulate existing performer (override temp UUID with server ID)
        existing = PerformerFactory(id="123", name="Jane Doe")
        print(existing.id)  # "123"

        # With relationships (use helpers after creation)
        performer = PerformerFactory()
        await performer.add_tag(tag)  # Bidirectional sync
    """

    class Meta:
        model = Performer

    # Required fields (ID auto-generated by Pydantic, don't set here)
    name = Sequence(lambda n: f"Performer_{n}")

    # Lists with default factories (required fields)
    alias_list = LazyFunction(list)
    tags = LazyFunction(list)
    stash_ids = LazyFunction(list)
    scenes = LazyFunction(list)
    groups = LazyFunction(list)
    urls = LazyFunction(list)

    # Optional fields (omitted = UNSET, can override in tests)
    # disambiguation, gender, birthdate, ethnicity, country, eye_color,
    # height_cm, measurements, fake_tits, penis_length, circumcised,
    # career_length, tattoos, piercings, image_path, details,
    # death_date, hair_color, weight


class StudioFactory(Factory):
    """Factory for Studio Pydantic type from stash-graphql-client.

    Creates Studio instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New studio (temp UUID)
        studio = StudioFactory(name="Test Studio")

        # Simulate existing studio (override temp UUID)
        existing = StudioFactory(id="123", name="Test Studio")

        # With parent relationship
        child = StudioFactory(parent_studio=parent_studio)
    """

    class Meta:
        model = Studio

    # Required fields (ID auto-generated by Pydantic)
    name = Sequence(lambda n: f"Studio_{n}")

    # Optional fields with defaults
    urls = LazyAttribute(lambda _: [])
    aliases = LazyAttribute(lambda _: [])
    tags = LazyAttribute(lambda _: [])
    stash_ids = LazyAttribute(lambda _: [])

    # Optional fields (omitted = UNSET): parent_studio, details, image_path


class TagFactory(Factory):
    """Factory for Tag Pydantic type from stash-graphql-client.

    Creates Tag instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New tag (temp UUID)
        tag = TagFactory(name="Documentary")

        # Simulate existing tag
        existing = TagFactory(id="789", name="Documentary")

        # With parent/child relationships
        child_tag = TagFactory(parents=[parent_tag])
    """

    class Meta:
        model = Tag

    # Required fields (ID auto-generated by Pydantic)
    name = Sequence(lambda n: f"Tag_{n}")

    # Lists with default factories (required fields)
    aliases = LazyFunction(list)
    parents = LazyFunction(list)
    children = LazyFunction(list)

    # Optional fields (omitted = UNSET): description, image_path


class SceneFactory(Factory):
    """Factory for Scene Pydantic type from stash-graphql-client.

    Creates Scene instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New scene (temp UUID)
        scene = SceneFactory(title="Test Scene")

        # Simulate existing scene
        existing = SceneFactory(id="1001", title="Test Scene")

        # With relationships (use helpers after creation)
        scene = SceneFactory()
        await scene.add_performer(performer)  # Bidirectional sync
        await scene.add_tag(tag)
        scene.studio = studio  # Direct assignment for one-to-one

        # Partial update (only title sent to server)
        update = SceneFactory(title="New Title")  # Other fields UNSET
    """

    class Meta:
        model = Scene

    # Required fields (ID auto-generated by Pydantic)
    title = Sequence(lambda n: f"Scene_{n}")

    # Lists with default factories
    files = LazyFunction(list)
    tags = LazyFunction(list)
    performers = LazyFunction(list)
    stash_ids = LazyFunction(list)
    groups = LazyFunction(list)
    urls = LazyFunction(list)
    galleries = LazyFunction(list)
    scene_markers = LazyFunction(list)
    sceneStreams = LazyFunction(list)
    captions = LazyFunction(list)

    # Optional fields (omitted = UNSET, can override in tests)
    # code, details, director, date, rating100, o_counter, organized, studio, paths


class GalleryFactory(Factory):
    """Factory for Gallery Pydantic type from stash-graphql-client.

    Creates Gallery instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New gallery (temp UUID)
        gallery = GalleryFactory(title="Test Gallery")

        # Simulate existing gallery
        existing = GalleryFactory(id="2001", title="Test Gallery", image_count=50)

        # With relationships
        gallery = GalleryFactory()
        await gallery.add_performer(performer)
    """

    class Meta:
        model = Gallery

    # Required fields (ID auto-generated by Pydantic)
    title = Sequence(lambda n: f"Gallery_{n}")

    # Lists with default factories
    files = LazyFunction(list)
    tags = LazyFunction(list)
    performers = LazyFunction(list)
    scenes = LazyFunction(list)
    urls = LazyFunction(list)
    chapters = LazyFunction(list)

    # Optional fields (omitted = UNSET): code, date, details, photographer,
    # rating100, organized, studio, image_count, folder


class ImageFactory(Factory):
    """Factory for Image Pydantic type from stash-graphql-client.

    Creates Image instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New image (temp UUID)
        image = ImageFactory(title="Test Image")

        # Simulate existing image
        existing = ImageFactory(id="3001", title="Test Image", organized=True)

        # With relationships
        image = ImageFactory()
        await image.add_performer(performer)
    """

    class Meta:
        model = Image

    # Required fields (ID auto-generated by Pydantic)
    title = Sequence(lambda n: f"Image_{n}")

    # Lists with default factories
    visual_files = LazyFunction(list)
    tags = LazyFunction(list)
    performers = LazyFunction(list)
    galleries = LazyFunction(list)
    urls = LazyFunction(list)

    # Optional fields (omitted = UNSET): code, date, details, photographer,
    # organized, studio, paths


class GroupFactory(Factory):
    """Factory for Group Pydantic type from stash-graphql-client.

    Creates Group instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New group (temp UUID)
        group = GroupFactory(name="Test Series")

        # Simulate existing group
        existing = GroupFactory(id="4001", name="Test Series", duration=7200)

        # With relationships
        group = GroupFactory(studio=studio)
    """

    class Meta:
        model = Group

    # Required fields (ID auto-generated by Pydantic)
    name = Sequence(lambda n: f"Group_{n}")

    # Lists with default factories
    tags = LazyFunction(list)
    scenes = LazyFunction(list)
    urls = LazyFunction(list)
    containing_groups = LazyFunction(list)
    sub_groups = LazyFunction(list)

    # Optional fields (omitted = UNSET): aliases, duration, date, studio,
    # director, synopsis, front_image_path, back_image_path


class ImageFileFactory(Factory):
    """Factory for ImageFile Pydantic type from stash-graphql-client.

    Creates ImageFile instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New image file (temp UUID)
        image_file = ImageFileFactory(path="/test/images/img.jpg")

        # Simulate existing file (override temp UUID)
        existing = ImageFileFactory(
            id="8001",
            path="/path/to/image.jpg",
            width=1920,
            height=1080
        )
    """

    class Meta:
        model = ImageFile

    # Required fields from BaseFile (ID auto-generated by Pydantic)
    path = Sequence(lambda n: f"/test/images/image_{n}.jpg")
    basename = Sequence(lambda n: f"image_{n}.jpg")
    parent_folder_id = "folder_1"
    mod_time = LazyFunction(lambda: datetime.now(UTC))
    size = 1024000  # 1 MB default

    # Required fields - fingerprints list
    fingerprints = LazyFunction(list[Fingerprint])

    # ImageFile specific required fields
    width = 1920
    height = 1080

    # Optional fields (omitted = UNSET): zip_file_id


class VideoFileFactory(Factory):
    """Factory for VideoFile Pydantic type from stash-graphql-client.

    Creates VideoFile instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New video file (temp UUID)
        video_file = VideoFileFactory(path="/test/videos/video.mp4")

        # Simulate existing file (override temp UUID)
        existing = VideoFileFactory(
            id="9001",
            path="/path/to/video.mp4",
            duration=3600.0,
            video_codec="h264"
        )
    """

    class Meta:
        model = VideoFile

    # Required fields from BaseFile (ID auto-generated by Pydantic)
    path = Sequence(lambda n: f"/test/videos/video_{n}.mp4")
    basename = Sequence(lambda n: f"video_{n}.mp4")
    parent_folder_id = "folder_1"
    mod_time = LazyFunction(lambda: datetime.now(UTC))
    size = 10240000  # 10 MB default

    # Required fields - fingerprints list
    fingerprints = LazyFunction(list[Fingerprint])

    # VideoFile specific required fields
    format = "mp4"
    width = 1920
    height = 1080
    duration = 60.0  # 60 seconds
    video_codec = "h264"
    audio_codec = "aac"
    frame_rate = 30.0
    bit_rate = 5000000  # 5 Mbps

    # Optional fields (omitted = UNSET): zip_file_id


class JobFactory(Factory):
    """Factory for Job Pydantic type from stash-graphql-client.

    Creates Job instances for testing. Pydantic auto-generates temp UUID.

    Examples:
        # New job (temp UUID, finished status)
        job = JobFactory(status=JobStatus.FINISHED)

        # Simulate running job (override temp UUID)
        running = JobFactory(
            id="job_123",
            status=JobStatus.RUNNING,
            progress=50.0,
            description="Scanning metadata"
        )
    """

    class Meta:
        model = Job

    # Required fields (ID auto-generated by Pydantic)
    status = JobStatus.FINISHED
    subTasks = LazyFunction(list)
    description = Sequence(lambda n: f"Job_{n}")
    addTime = LazyFunction(lambda: datetime.now(UTC))

    # Optional fields (omitted = UNSET): progress, startTime, endTime, error


# ============================================================================
# Pytest Fixtures for Stash API Types
# ============================================================================


@pytest.fixture
def mock_performer():
    """Fixture for Performer test instance.

    Returns a real Performer object (not a mock) using PerformerFactory.
    All Performer methods work as expected.

    Example:
        def test_something(mock_performer):
            assert mock_performer.name == "Performer_0"
            assert mock_performer.id == "100"
    """
    return PerformerFactory(id="123", name="test_user")


@pytest.fixture
def mock_studio():
    """Fixture for Studio test instance.

    Returns a real Studio object (not a mock) using StudioFactory.

    Example:
        def test_something(mock_studio):
            assert mock_studio.name == "Test Studio"
            assert mock_studio.id == "123"
    """
    return StudioFactory(id="123", name="Test Studio")


@pytest.fixture
def mock_tag():
    """Fixture for Tag test instance.

    Returns a real Tag object (not a mock) using TagFactory.

    Example:
        def test_something(mock_tag):
            assert mock_tag.name == "test_tag"
            assert mock_tag.id == "123"
    """
    return TagFactory(id="123", name="test_tag")


@pytest.fixture
def mock_scene():
    """Fixture for Scene test instance.

    Returns a real Scene object (not a mock) using SceneFactory.

    Example:
        def test_something(mock_scene):
            assert mock_scene.title == "Test Scene"
            assert mock_scene.id == "123"
    """
    return SceneFactory(id="123", title="Test Scene")


@pytest.fixture
def mock_gallery():
    """Fixture for Gallery test instance.

    Returns a real Gallery object (not a mock) using GalleryFactory.

    Example:
        def test_something(mock_gallery):
            assert mock_gallery.title == "Test Gallery"
            assert mock_gallery.id == "123"
    """
    return GalleryFactory(
        id="123",
        title="Test Gallery",
        code="12345",
        organized=True,
    )


@pytest.fixture
def mock_image():
    """Fixture for Image test instance.

    Returns a real Image object (not a mock) using ImageFactory.

    Example:
        def test_something(mock_image):
            assert mock_image.title == "Test Image"
            assert mock_image.id == "123"
    """
    return ImageFactory(
        id="123",
        title="Test Image",
        organized=False,
    )


@pytest.fixture
def mock_image_file():
    """Fixture for ImageFile test instance.

    Returns a real ImageFile object (not a mock) using ImageFileFactory.

    Example:
        def test_something(mock_image_file):
            assert mock_image_file.path == "/path/to/image.jpg"
            assert mock_image_file.width == 1920
    """
    return ImageFileFactory(
        id="123",
        path="/path/to/image.jpg",
        basename="image.jpg",
        size=12345,
        width=1920,
        height=1080,
    )


@pytest.fixture
def mock_video_file():
    """Fixture for VideoFile test instance.

    Returns a real VideoFile object (not a mock) using VideoFileFactory.

    Example:
        def test_something(mock_video_file):
            assert mock_video_file.path == "/path/to/video.mp4"
            assert mock_video_file.duration == 60.0
    """
    return VideoFileFactory(
        id="456",
        path="/path/to/video.mp4",
        basename="video.mp4",
        size=123456,
        duration=60.0,
        video_codec="h264",
        audio_codec="aac",
        width=1920,
        height=1080,
    )


# Export all factories and fixtures
__all__ = [
    # Factories
    "GalleryFactory",
    "GroupFactory",
    "ImageFactory",
    "ImageFileFactory",
    "JobFactory",
    "PerformerFactory",
    "SceneFactory",
    "StudioFactory",
    "TagFactory",
    "VideoFileFactory",
    # Pytest fixtures
    "mock_gallery",
    "mock_image",
    "mock_image_file",
    "mock_performer",
    "mock_scene",
    "mock_studio",
    "mock_tag",
    "mock_video_file",
]
